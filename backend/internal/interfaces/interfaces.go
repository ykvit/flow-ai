// Package interfaces defines the contracts (Go interfaces) for the core
// services in the application.
//
// WHY THIS PACKAGE EXISTS:
// This package is central to our adherence to the Dependency Inversion Principle,
// a cornerstone of Clean Architecture. By defining interfaces here, we create a
// clear boundary between the application's layers.
//
// For example, the API layer (`internal/api`) depends on these interfaces, not
// on the concrete service implementations in `internal/service`. This decoupling
// provides two major benefits:
//
//  1. Flexibility: We could swap out a service implementation with a different
//     one without changing any code in the API layer, as long as the new
//     implementation satisfies the contract.
//  2. Testability: This is the primary reason for this package. In our unit
//     tests for the API handlers, we can easily provide a mock implementation
//     (generated by `mockery`) of these interfaces. This allows us to test the
//     handler's logic (request parsing, response formatting) in complete
//     isolation, without executing any actual business logic.
package interfaces

import (
	"context"

	"flow-ai/backend/internal/llm"
	"flow-ai/backend/internal/model"
	"flow-ai/backend/internal/service"
)

// ChatService defines the contract for all chat-related business logic.
// Any struct that implements all these methods is considered a `ChatService`.
type ChatService interface {
	UpdateChatTitle(ctx context.Context, chatID, newTitle string) error
	DeleteChat(ctx context.Context, chatID string) error
	ListChats(ctx context.Context) ([]*model.Chat, error)
	GetFullChat(ctx context.Context, chatID string) (*model.FullChat, error)
	// HandleNewMessage is designed for concurrent operation. It accepts a write-only
	// channel and is expected to run its logic (e.g., call the LLM) in a goroutine,
	// sending results back through the channel.
	HandleNewMessage(ctx context.Context, req *service.CreateMessageRequest, streamChan chan<- model.StreamResponse)
	RegenerateMessage(ctx context.Context, chatID string, originalAssistantMessageID string, req *service.RegenerateMessageRequest, streamChan chan<- model.StreamResponse)
}

// ModelService defines the contract for all business logic related to managing
// local Ollama models.
type ModelService interface {
	List(ctx context.Context) (*llm.ListModelsResponse, error)
	// Pull accepts a channel to stream progress updates back to the caller.
	Pull(ctx context.Context, req *llm.PullModelRequest, ch chan<- llm.PullStatus) error
	Delete(ctx context.Context, req *llm.DeleteModelRequest) error
	Show(ctx context.Context, req *llm.ShowModelRequest) (*llm.ModelInfo, error)
}

// SettingsService defines the contract for managing global application settings.
// This includes initialization, retrieval, and saving of settings.
type SettingsService interface {
	// InitAndGet is a special method intended to be called at application startup.
	// It ensures that settings exist and creates them if they don't.
	InitAndGet(ctx context.Context, defaultSystemPrompt string) (*service.Settings, error)
	Get(ctx context.Context) (*service.Settings, error)
	Save(ctx context.Context, settings *service.Settings) error
}
