package service_test

import (
	"context"
	"database/sql"
	"errors"
	"testing"

	"github.com/DATA-DOG/go-sqlmock"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
	"github.com/stretchr/testify/require"

	"flow-ai/backend/internal/llm"
	mock_llm "flow-ai/backend/internal/llm/mocks"
	"flow-ai/backend/internal/model"
	"flow-ai/backend/internal/repository"
	mock_repo "flow-ai/backend/internal/repository/mocks"
	"flow-ai/backend/internal/service"
)

// Mocks is a helper struct to bundle all mock dependencies for `ChatService`.
//
// WHY: This makes the setup function `setupChatService` cleaner and easier to
// manage as the number of dependencies grows.
type Mocks struct {
	repo   *mock_repo.MockRepository
	llm    *mock_llm.MockLLMProvider
	db     *sql.DB
	mockDB sqlmock.Sqlmock
}

// setupChatService is a test fixture that creates a `ChatService` instance
// with all its external dependencies replaced by mocks.
//
// WHY: This is the core of our unit testing strategy. `ChatService` has multiple
// dependencies (`Repository`, `LLMProvider`, `SettingsService`). To test it in
// isolation, we need to control the behavior of these dependencies.
//
//   - `mock_repo` and `mock_llm` are generated by `mockery`.
//   - `sqlmock` creates a mock `*sql.DB`, which is then passed to a *real*
//     `SettingsService` instance. This allows us to test the integration between
//     `ChatService` and a real `SettingsService` while still controlling the
//     underlying database calls.
func setupChatService(t *testing.T) (*service.ChatService, Mocks) {
	db, mockDB, err := sqlmock.New()
	require.NoError(t, err)

	mocks := Mocks{
		repo:   mock_repo.NewMockRepository(t),
		llm:    mock_llm.NewMockLLMProvider(t),
		db:     db,
		mockDB: mockDB,
	}

	settingsService := service.NewSettingsService(mocks.db, mocks.llm)
	chatService := service.NewChatService(mocks.repo, mocks.llm, settingsService)

	return chatService, mocks
}

// TestChatService_UpdateChatTitle tests the simple pass-through logic of this method.
func TestChatService_UpdateChatTitle(t *testing.T) {
	ctx := context.Background()
	chatID := "chat123"
	newTitle := "New Title"

	t.Run("Success", func(t *testing.T) {
		// ARRANGE
		chatService, mocks := setupChatService(t)
		defer func() { _ = mocks.db.Close() }() // Close mock DB connection

		// We expect the service to call the repository's `UpdateChatTitle` method once.
		mocks.repo.On("UpdateChatTitle", ctx, chatID, newTitle).Return(nil).Once()

		// ACT
		err := chatService.UpdateChatTitle(ctx, chatID, newTitle)

		// ASSERT
		assert.NoError(t, err)
	})

	t.Run("Failure - Repository returns not found", func(t *testing.T) {
		// GOAL: Verify that repository-level errors are correctly translated/propagated.
		// ARRANGE
		chatService, mocks := setupChatService(t)
		defer func() { _ = mocks.db.Close() }()
		mocks.repo.On("UpdateChatTitle", ctx, chatID, newTitle).Return(repository.ErrNotFound).Once()

		// ACT
		err := chatService.UpdateChatTitle(ctx, chatID, newTitle)

		// ASSERT
		assert.Error(t, err)
		assert.ErrorContains(t, err, "not found")
	})
}

// TestChatService_ListChats tests another simple pass-through method.
func TestChatService_ListChats(t *testing.T) {
	// ARRANGE
	ctx := context.Background()
	chatService, mocks := setupChatService(t)
	defer func() { _ = mocks.db.Close() }()

	expectedChats := []*model.Chat{{ID: "chat1"}}
	mocks.repo.On("GetChats", ctx).Return(expectedChats, nil).Once()

	// ACT
	chats, err := chatService.ListChats(ctx)

	// ASSERT
	assert.NoError(t, err)
	assert.Equal(t, expectedChats, chats)
}

// TestChatService_GetFullChat tests the logic of aggregating chat and message data.
func TestChatService_GetFullChat(t *testing.T) {
	ctx := context.Background()
	chatID := "chat123"

	t.Run("Success", func(t *testing.T) {
		// GOAL: Verify that the service correctly calls both `GetChat` and
		// `GetActiveMessagesByChatID` and assembles the results.
		// ARRANGE
		chatService, mocks := setupChatService(t)
		defer func() { _ = mocks.db.Close() }()

		chat := &model.Chat{ID: chatID}
		messages := []model.Message{{ID: "msg1"}}

		mocks.repo.On("GetChat", ctx, chatID).Return(chat, nil).Once()
		mocks.repo.On("GetActiveMessagesByChatID", ctx, chatID).Return(messages, nil).Once()

		// ACT
		fullChat, err := chatService.GetFullChat(ctx, chatID)

		// ASSERT
		require.NoError(t, err)
		assert.Equal(t, chat, &fullChat.Chat)
		assert.Equal(t, messages, fullChat.Messages)
	})

	t.Run("Failure - GetChat returns error", func(t *testing.T) {
		// GOAL: Verify that an error from the first repository call is propagated immediately.
		chatService, mocks := setupChatService(t)
		defer func() { _ = mocks.db.Close() }()

		mocks.repo.On("GetChat", ctx, chatID).Return(nil, errors.New("db error")).Once()
		// We should NOT expect a call to `GetActiveMessagesByChatID` if the first call fails.

		_, err := chatService.GetFullChat(ctx, chatID)
		assert.Error(t, err)
	})

	t.Run("Failure - GetActiveMessagesByChatID returns error", func(t *testing.T) {
		// GOAL: Verify that an error from the second repository call is also handled.
		chatService, mocks := setupChatService(t)
		defer func() { _ = mocks.db.Close() }()

		mocks.repo.On("GetChat", ctx, chatID).Return(&model.Chat{}, nil).Once()
		mocks.repo.On("GetActiveMessagesByChatID", ctx, chatID).Return(nil, errors.New("db error")).Once()

		_, err := chatService.GetFullChat(ctx, chatID)
		assert.Error(t, err)
	})
}

// TestChatService_HandleNewMessage_NewChat focuses on the complex logic for creating a new chat.
func TestChatService_HandleNewMessage_NewChat(t *testing.T) {
	ctx := context.Background()
	req := &service.CreateMessageRequest{Content: "Hello"}

	t.Run("Success - Happy Path", func(t *testing.T) {
		// GOAL: This is a crucial test that verifies the entire sequence of operations for a new message.
		chatService, mocks := setupChatService(t)
		defer func() { _ = mocks.db.Close() }()
		streamChan := make(chan model.StreamResponse, 5)

		// ARRANGE: We must configure a complex chain of mock expectations.
		// 1. Settings are fetched successfully.
		rows := sqlmock.NewRows([]string{"key", "value"}).
			AddRow("system_prompt", "system").
			AddRow("main_model", "test-model").
			AddRow("support_model", "support-model")
		mocks.mockDB.ExpectQuery("SELECT key, value FROM settings").WillReturnRows(rows)

		// 2. A new chat is created.
		mocks.repo.On("CreateChat", ctx, mock.AnythingOfType("*model.Chat")).Return(nil).Once()
		// 3. The service checks for a previous message (finds none).
		mocks.repo.On("GetLastActiveMessage", ctx, mock.AnythingOfType("string")).Return(nil, repository.ErrNotFound).Once()
		// 4. The user's message and the assistant's final message are added.
		mocks.repo.On("AddMessage", ctx, mock.AnythingOfType("*model.Message"), mock.AnythingOfType("string")).Return(nil).Twice()
		// 5. Message history is fetched for the LLM context.
		mocks.repo.On("GetActiveMessagesByChatID", ctx, mock.AnythingOfType("string")).Return([]model.Message{}, nil).Once()
		// 6. The final LLM context is saved to the assistant's message.
		mocks.repo.On("UpdateMessageContext", ctx, mock.Anything, mock.Anything).Return(nil).Once()
		// 7. A title is generated and updated in the background (optional calls).
		mocks.repo.On("UpdateChatTitle", mock.Anything, mock.AnythingOfType("string"), mock.AnythingOfType("string")).Return(nil).Maybe()
		mocks.llm.On("Generate", mock.Anything, mock.Anything).Return(&llm.GenerateResponse{Response: `{"title": "Test"}`}, nil).Maybe()

		// 8. The LLM stream is called and simulated.
		mocks.llm.On("GenerateStream", mock.Anything, mock.Anything, mock.Anything).
			Return(nil).
			Run(func(args mock.Arguments) {
				outChan := args.Get(2).(chan<- llm.StreamResponse)
				outChan <- llm.StreamResponse{Content: "response"}
				outChan <- llm.StreamResponse{Done: true, Context: []byte(`"context"`)}
				close(outChan)
			}).Once()

		// ACT
		chatService.HandleNewMessage(ctx, req, streamChan)

		// ASSERT: Check the output channel and verify all mock expectations were met.
		assert.Len(t, streamChan, 2)
		<-streamChan
		finalChunk := <-streamChan
		assert.True(t, finalChunk.Done)

		require.NoError(t, mocks.mockDB.ExpectationsWereMet())
		mocks.repo.AssertExpectations(t)
		mocks.llm.AssertExpectations(t)
	})

	t.Run("Failure - Settings service returns error", func(t *testing.T) {
		chatService, mocks := setupChatService(t)
		defer func() { _ = mocks.db.Close() }()
		streamChan := make(chan model.StreamResponse, 1)

		// ARRANGE: Simulate a DB error when fetching settings.
		mocks.mockDB.ExpectQuery("SELECT key, value FROM settings").WillReturnError(errors.New("db error"))

		// ACT
		chatService.HandleNewMessage(ctx, req, streamChan)

		// ASSERT: Verify an error is sent through the stream channel.
		errChunk := <-streamChan
		assert.NotEmpty(t, errChunk.Error)
		assert.Contains(t, errChunk.Error, "Could not load application settings")
		require.NoError(t, mocks.mockDB.ExpectationsWereMet())
	})

	t.Run("Failure - CreateChat returns error", func(t *testing.T) {
		chatService, mocks := setupChatService(t)
		defer func() { _ = mocks.db.Close() }()
		streamChan := make(chan model.StreamResponse, 1)

		// ARRANGE: Settings are fine, but creating the chat in the DB fails.
		rows := sqlmock.NewRows([]string{"key", "value"}).
			AddRow("system_prompt", "system").
			AddRow("main_model", "test-model")
		mocks.mockDB.ExpectQuery("SELECT key, value FROM settings").WillReturnRows(rows)
		mocks.repo.On("CreateChat", ctx, mock.Anything).Return(errors.New("db error")).Once()

		// ACT
		chatService.HandleNewMessage(ctx, req, streamChan)

		// ASSERT
		errChunk := <-streamChan
		assert.NotEmpty(t, errChunk.Error)
		assert.Contains(t, errChunk.Error, "Could not create chat")
		require.NoError(t, mocks.mockDB.ExpectationsWereMet())
	})
}
